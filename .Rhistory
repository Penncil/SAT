document()
library(roxygen2)
document()
library(devtools)
document()
use_data_raw("generate_internal")
n <- 1e5
r1 <- 400
r <- 800
beta0  <- c(-1/2, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
corr  <- 0.5
sigmax  <- matrix(corr, d-1, d-1) + diag(1-corr, d-1)
set.seed(0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
mean(Y)
X <- rnorm(n*(d-1), -1.3, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
beta0  <- c(-1/5, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
corr  <- 0.5
sigmax  <- matrix(corr, d-1, d-1) + diag(1-corr, d-1)
set.seed(0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
mean(Y)
beta0  <- c(-1/10, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
corr  <- 0.5
sigmax  <- matrix(corr, d-1, d-1) + diag(1-corr, d-1)
set.seed(0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
mean(Y)
beta0  <- c(1/10, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
corr  <- 0.5
sigmax  <- matrix(corr, d-1, d-1) + diag(1-corr, d-1)
set.seed(0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
mean(Y)
beta0  <- c(1/5, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
corr  <- 0.5
sigmax  <- matrix(corr, d-1, d-1) + diag(1-corr, d-1)
set.seed(0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
mean(Y)
a1 <- 0.85 # sensitivity
a2 <- 0.95 # specificity
pr_s <- vector(mode = "numeric", length = n)
pr_s <- a1*(Y==1) + (1-a2)*(Y==0)
S <- rbinom(n, 1, pr_s)
mean9S)
mean(S)
install()
library(SAT)
library(SAT)
? getMLE
? SAT.estimation
? SAT.stage1.sampling
? SAT.stage2.sampling
document()
? SAT.stage2.sampling
document()
? SAT.estimation
install()
library(SAT)
? SAT.stage1.sampling
? SAT.stage2.sampling
library(SAT)
library(SAT)
? SAT.stage2.sampling
stage1.index <- SAT.stage1.sampling(r1 = 400, n = 1e5, S, Rpar = 0.5)
data(generate_internal)
document()
install()
library(SAT)
? SAT.stage1.sampling
remove.packages("SAT")
install()
library(SAT)
.rs.restartR()
library(SAT)
document()
document()
install()
library(SAT)
? getMLE
? SAT.estimation
stage1.index <- SAT.stage1.sampling(r1 = 400, n = 1e5, S, Rpar = 0.5)
document()
install()
install()
library(SAT)
.rs.restartR()
library(SAT)
? getMLE
? SAT.estimation
set.seed(0)
n <- 1e5
beta0  <- c(1/5, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
a1 <- 0.85 # sensitivity
a2 <- 0.95 # specificity
pr_s <- vector(mode = "numeric", length = n)
pr_s <- a1*(Y==1) + (1-a2)*(Y==0)
S <- rbinom(n, 1, pr_s)
stage1.index <- SAT.stage1.sampling(r1 = 400, n = 1e5, S, Rpar = 0.5)
stage1.y <- Y[stage1.index]
stage2 <- SAT.stage2.sampling(r1 = 400, n = 1e5, S, Rpar, r = 800,
stage1.index, stage1.y, X, method = "SAT-S")
stage2.y <-  Y[stage2$stage2.index]
document()
library(SAT)
? SAT.estimation
stage2 <- SAT.stage2.sampling(r1 = 400, n = 1e5, S, Rpar = 0.5, r = 800,
stage1.index, stage1.y, X, method = "SAT-S")
stage2.y <-  Y[stage2$stage2.index]
SAT.est <- SAT.estimation(S, X, beta.pilot = stage2$beta.pilot, stage1.index = stage1.index,
stage2.index = stage2$stage2.index,
stage1.weights = stage2$stage1.weights,
stage1.y = stage1.y, stage2.y = stage2.y,
method = "SAT-S")
SAT.est
? SAT.stage1.sampling
document()
? SAT.stage1.sampling
document()
? SAT.stage1.sampling
document()
? SAT.stage1.sampling
document()
? SAT.stage1.sampling
document()
? SAT.stage1.sampling
? SAT.stage2.sampling
document()
document()
? SAT.stage2.sampling
document()
? SAT.stage2.sampling
document()
? SAT.stage2.sampling
document()
? SAT.stage2.sampling
document()
? SAT.stage2.sampling
document()
? SAT.estimation
document()
? SAT.estimation
document()
? SAT.estimation
set.seed(0)
n <- 1e5
beta0  <- c(1/5, 0, 0, 1/2, rep(1/2, 4))
d <- length(beta0)
X <- rnorm(n*(d-1), -1.5, 1)
X <- matrix(X, nrow = n, ncol = d - 1)
X <- cbind(1, X)
P  <- 1 - 1 / (1 + exp(X %*% beta0))
Y  <- rbinom(n, 1, P)
a1 <- 0.85 # sensitivity
a2 <- 0.95 # specificity
pr_s <- vector(mode = "numeric", length = n)
pr_s <- a1*(Y==1) + (1-a2)*(Y==0)
S <- rbinom(n, 1, pr_s)
stage1.index <- SAT.stage1.sampling(r1 = 400, n = 1e5, S, Rpar = 0.5)
stage1.y <- Y[stage1.index]
stage2 <- SAT.stage2.sampling(r1 = 400, n = 1e5, S, Rpar = 0.5, r = 800,
stage1.index, stage1.y, X, method = "SAT-cY")
stage2.y <-  Y[stage2$stage2.index]
SAT.est <- SAT.estimation(S, X, beta.pilot = stage2$beta.pilot, stage1.index = stage1.index,
stage2.index = stage2$stage2.index,
stage1.weights = stage2$stage1.weights,
stage1.y = stage1.y, stage2.y = stage2.y,
method = "SAT-cY")
SAT.est
.rs.restartR()
install()
library(SAT)
? getMLE
document()
? SAT.estimation
document()
? SAT.estimation
document()
1-c(1,0,0)
c(1,0,0)*(1:3)
c(1,1,0)*(1:3)
mat1 <- matrix(1:9,3,3)
mat1[c(1,2,0),]
mat1[c(1,0,3),]
mat1
################################################
#  Generated data for illustration     #
###############################################
beta = c(-4,1,-1,1,-1) #just for generating X and Y
p = length(beta)
####data in K sites####
K = 10 # Suppose there are 10 sites (include the local)
n = 1000 #sample size in each site
N = K*n
X1 = rnorm(N)
X2 = rbinom(N,1,0.3)
X3 = runif(N,-1,1)
X4 = rnorm(N,0,2)
X = cbind(1,X1,X2,X3,X4)
meanY = expit(X%*%beta)
expit = function(x){exp(x)/(1+exp(x))}
meanY = expit(X%*%beta)
Y = rbinom(N,1,meanY)
####### All data #######
Xall = X[,2:p]
Yall = Y
site =rep(1:K, each = n)
hete_index=c(1,0,1)
local_site=1
#likelihood function for logistic regression, the input X is a n*d matrix where
#each patient has d covariates stored in each row.
Lik = function(beta,X,Y){
design = cbind(1,X)
sum(Y*(design%*%t(t(beta)))-log(1+exp(design%*%t(t(beta)))))/length(Y)
}
#first order gradient
Lgradient = function(beta,X,Y){
design = cbind(1,X)
t(Y-expit(design%*%t(t(beta))))%*%design/length(Y)
}
#first-order surrogate likelihood, suppose the local data are stored in Xlocal,Ylocal
SL = function(beta){
-Lik(beta,Xlocal,Ylocal) - L%*%beta
}
#second-order gradient
Lgradient2 =function(beta,X){
design = cbind(1,X)
Z=expit(design%*%beta)
t(c(-1*Z*(1-Z))*design)%*%design/nrow(X)
}
#second-order surogate likelihood
SL2 = function(beta){
beta_temp = beta - betabar
-Lik(beta,Xlocal,Ylocal) - L%*%beta - 0.5*t(beta_temp)%*%L2%*%t(t(beta_temp))
}
K = length(unique(site))
p
hete_index
hete_index=c(1,0,1,0,0)
######################################
# PART 3.. Meta estimator  #
#####################################
Beta = matrix(0,nrow = K,ncol = p) # Store the estimator in each site
VBeta = matrix(0,nrow = K,ncol = p)# Store the covariance matrix from each site (each is a p*p matrix, we expand it into a vector)
#fit logistic regression in each site
for (i in 1:K){
Xsite = Xall[which(site==i),] #Predictors in the ith site
Ysite = Yall[which(site==i)]  #Outcomes in the ith site
Beta[i,] = tryCatch(glm(Ysite~Xsite, family = "binomial"(link = "logit"))$coefficients,error=function(err) rep(NA,length(betaall)))
if(sum(is.na(Beta[i,]))!=0){
Beta[i,] = rep(NA,length(betaall))
VBeta[i,] = rep(NA,length(betaall))
}
else{ VBeta[i,] = summary(glm(Ysite~Xsite, family = "binomial"(link = "logit")))$coefficients[,2]^2}
}
#estimate from meta-analysis
betameta = apply(Beta/VBeta,2,function(x){sum(x, na.rm = T)})/apply(1/VBeta,2,function(x){sum(x, na.rm = T)})
vmeta = 1/apply(1/VBeta,2,function(x){sum(x, na.rm = T)})
#initial value, could be local or meta estimator
betabar = betameta
#calculate the gradient in each site
L = matrix(0,nrow = K,ncol = p) # Store the first order gradient (each is a p-dimensional vector)
L2 = array(0, dim = c(K, p, p)) # Store the second order gradient (each is a p*p matrix, we expand it into a vector)
effscore_L = rep(0, p - sum(hete_index))
effscore_L2 = matrix(0, p - sum(hete_index), p - sum(hete_index))
p - sum(hete_index)
share_index = 1 - hete_index
share_index
I_hete = diag(p)[hete_index*(1:p), ]
I_hete
I_share
I_share = diag(p)[share_index*(1:p), ]
I_share
for (i in 1:K){
Xsite = Xall[which(site==i),]          #Predictors in the ith site
Ysite = Yall[which(site==i)]           #Outcomes in the ith site
L[i,] = Lgradient(betabar,Xsite,Ysite) #first order gradient in the ith site
L2[i,,] = Lgradient2(betabar,Xsite)    #second order gradient in the ith site
effscore_L2 = effscore_L2 + I_share%*%L2[i,,]%*%t(I_share) -
I_share%*%L2[i,,]%*%t(I_hete)%*%solve(I_hete%*%L2[i,,]%*%t(I_hete))%*%I_hete%*%L2[i,,]%*%t(I_share)
effscore_L = effscore_L + I_share%*%L[i,] - I_share%*%L2[i,,]%*%t(I_hete)%*%solve(I_hete%*%L2[i,,]%*%t(I_hete))%*%I_hete%*%L[i,]
}
Beta_2pda = betabar - solve(effscore_L2)%*%effscore_L
effscore_L2
betabar
share_index*(1:p)
betabar[share_index*(1:p)]
Beta_2pda = betabar[share_index*(1:p)] - solve(effscore_L2)%*%effscore_L
Beta_2pda
Beta
beta
cbind(Beta_2pda, beta[c(2,4,5)], betabar[c(2,4,5)])
